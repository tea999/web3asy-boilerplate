import { ACTION } from "../utils/const";
import { hmacCallApi } from "../utils/request";
import {
  ApprovalBody,
  Authorization,
  GenerateAddressesOptions,
  ListAddressesCriteria,
  ListTransactionsCriteria,
  ListWalletsCriteria,
  Object,
} from "../utils/typedef";
import { ecSign, getECPublicKey } from "../utils/util";

/**
 * @class
 * @private  {string} _apiKey custonomy API key
 * @private  {string} _apiSecret custonomy API secret
 * @private  {string} _endpoint custonomy API endpoint
 * @private  {string} _tenant custonomy tenant name
 * @private  {string} _domain
 * @private  {string} _currentUser
 */
export default class Custonomy {
  private _apiKey: string;
  private _apiSecret: string;
  private _endpoint: string;
  private _tenant: string;
  private _domain: string;

  /**
   * @constructor
   * @params apiKey
   * @params apiSecret
   * @params endpoint
   * @params tenant
   * @params [domain] (default = MAIN)
   */
  constructor(
    apiKey: string,
    apiSecret: string,
    endpoint: string,
    tenant: string,
    domain: string = "MAIN"
  ) {
    this._apiKey = apiKey;
    this._apiSecret = apiSecret;
    this._endpoint = endpoint;
    this._tenant = tenant;
    this._domain = domain;
  }

  /**
   * Register EC master key for device
   * @param {string} privateKey EC private key generated by device
   * @param {string | null} username name of device
   * @param {string | null} displayName display name of device
   * @param {string} [incomingMessage] incoming message for device
   * @returns {Promise<Object>} user id
   */
  registerMasterKey = async (
    privateKey: string,
    username: string | null = null,
    displayName: string | null = null,
    incomingMessage?: string
  ) => {
    const incomeMsg: string =
      incomingMessage ?? JSON.stringify(new Date().toISOString());
    const signature: string = ecSign(incomeMsg, privateKey);
    const masterKey: string = getECPublicKey(privateKey);
    const registerMsg: string = Buffer.from(
      JSON.stringify({ message: incomeMsg, masterKey, signature })
    ).toString("base64");

    const body: Object = {
      username: username,
      displayName: displayName,
      registerMsg: registerMsg,
    };
    const query: Object = { action: "register", type: "signnode" };
    const path: string = `/v0/${this._tenant}/users`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.PATCH,
      query,
      body,
    });
  };

  /**
   * List Wallets
   * @param {Object} [criteria]
   * @param {string} [criteria.name] filter by wallet name
   * @param {string} [criteria.description] filter by wallet description
   * @param {string} [criteria.status] filter by wallet status
   * @param {boolean} [criteria.favorite] select favorite wallets only
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Object>} list of wallets
   */
  listWallets = async (
    criteria: ListWalletsCriteria = {},
    page: number = 1,
    rownum: number = 10
  ) => {
    const query: Object = { ...criteria, lite: true, page, rownum };
    const path: string = `/v0/${this._tenant}/${this._domain}/wallets/`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.GET,
      query,
    });
  };

  /**
   * Generate new address(es) under wallet
   * @async
   * @param {string} walletId wallet id
   * @param {string} chain chain
   * @param {GenerateAddressesOptions} [options] optional settings for generating address(es)
   * @param {string} [options.alias] alias to new address(es)
   * @param {number} [options.num] number of address(es) to be generated (default = 1)
   * @returns {Promise<Array<string>>} id of newly generated address(es)
   */
  generateAddresses = async (
    walletId: string,
    chain: string,
    options: GenerateAddressesOptions = {}
  ) => {
    const query: Object = { action: "generate", chain: chain, ...options };
    const path: string = `/v0/${this._tenant}/${this._domain}/wallets/${walletId}/addresses`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.POST,
      query,
    });
  };

  /**
   * List addresses of wallet
   * @async
   * @param {string} walletId wallet id
   * @param {string} [criteria]
   * @param {string} [criteria.chain] filter by chain
   * @param {string} [criteria.status] filter by status
   * @param {string} [criteria.addressIds] filter by address ids (address ids concatenated with ',')
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>} list of addresses of wallet
   */
  listAddresses = async (
    walletId: string,
    criteria: ListAddressesCriteria = {},
    page: number = 1,
    rownum: number = 10
  ) => {
    const query: Object = { ...criteria, page, rownum };
    const path: string = `/v0/${this._tenant}/${this._domain}/wallets/${walletId}/addresses`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.GET,
      query,
    });
  };

  /**
   * Get address by id
   * @async
   * @param {string} walletId wallet id
   * @param {string} addressId address id
   * @returns {Promise<Object>} address info
   */
  getAddress = async (walletId: string, addressId: string) => {
    const criteira: Object = { addressIds: addressId };
    return this.listAddresses(walletId, criteira)
      .then((res) => {
        return res.data?.length > 0 ? res.data[0] : null;
      })
      .catch((ex) => {
        throw ex;
      });
  };

  /**
   * Submit transaction
   * @async
   * @param {Object} transaction transaction details
   * @returns {Promise<Object>} object contains transaction id
   */
  submitTransaction = async (transaction: Object) => {
    const path: string = `/v0/${this._tenant}/${this._domain}/transactions`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.POST,
      body: transaction,
    });
  };

  /**
   * Update transaction
   * @async
   * @param {string} transactionId transaction id
   * @param {string} action action to perform (i.e. authorize)
   * @param {Authorization | Object} transaction update details
   * @returns {Promise<any>} update result
   */
  updateTransaction = async (
    transactionId: string,
    action: string,
    transaction: Authorization | Object
  ) => {
    const query: Object = { action };
    const path: string = `/v0/${this._tenant}/${this._domain}/transactions/${transactionId}`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.PATCH,
      query,
      body: transaction,
    });
  };

  /**
   * Get transaction info by id
   * @async
   * @param transactionId transaction id
   * @param lang display language (currently support: en)
   * @returns {Promise<Object>} transaction info
   */
  getTransaction = async (transactionId: string, lang?: string) => {
    const query: Object = lang ? { lang: lang.toLowerCase() } : {};
    const path: string = `/v0/${this._tenant}/${this._domain}/transactions/${transactionId}`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.GET,
      query,
    });
  };

  getInfo = async () => {
    // console.log('getInfo', this._endPoint)
    const path: string = `/v0/users`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.GET,
    })
      .then((result: any) => {
        if (result) {
          return result;
        }
      })
      .catch((ex: Error) => {
        console.error(ex);
        return null;
      });
  };

  /**
   * List transactions
   * @async
   * @param {Object} [criteria]
   * @param {string} [criteria.txnId]
   * @param {string} [criteria.refId]
   * @param {string} [criteria.chain]
   * @param {string} [criteria.subchain]
   * @param {string} [criteria.networks]
   * @param {string} [criteria.assets]
   * @param {string} [criteria.status]
   * @param {string} [criteria.walletId]
   * @param {string} [criteria.sortBy]
   * @param {string} [criteria.orderBy]
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>}
   */
  listTransactions = async (
    criteria: ListTransactionsCriteria = {},
    page: number = 1,
    rownum: number = 10
  ) => {
    const query: Object = { ...criteria, page, rownum };
    const path: string = `/v0/${this._tenant}/${this._domain}/transactions`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.GET,
      query,
    });
  };

  /**
   * List transactions by wallet id
   * @async
   * @param walletId wallet id
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>}
   */
  listTransactionsByWalletId = async (
    walletId: string,
    page: number = 1,
    rownum: number = 10
  ) => {
    return this.listTransactions({ walletId }, page, rownum);
  };

  /**
   * List transactions pending for current user's action
   * @async
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>}
   */
  listMyPendingTransactions = async (page: number = 1, rownum: number = 10) => {
    return this.listTransactions(
      { myActionPendingType: "APPROVAL,AUTHORIZATION" },
      page,
      rownum
    );
  };

  /**
   * List transactions pending for approval
   * @async
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>}
   */
  listPendingApprovalTransactions = async (
    page: number = 1,
    rownum: number = 10
  ) => {
    return this.listTransactions(
      { myActionPendingType: "APPROVAL" },
      page,
      rownum
    );
  };

  /**
   * List transactions pending for authorization
   * @async
   * @param {number} [page] page number (default = 1)
   * @param {number} [rownum] number of rows per page (default = 10)
   * @returns {Promise<Array<Object>>}
   */
  listPendingAuthorizeTransactions = async (
    page: number = 1,
    rownum: number = 10
  ) => {
    return this.listTransactions(
      { myActionPendingType: "AUTHORIZATION" },
      page,
      rownum
    );
  };

  /**
   * Update transaction approval status
   * @async
   * @param {string} stepId approval step id
   * @param {string} action approval action (i.e. approve, reject)
   * @param {string} [comment] comment on action (required by reject)
   * @returns {Promise<any>}
   */
  updateTransactionApproval = async (
    stepId: string,
    action: "approve" | "reject",
    comment?: string
  ) => {
    const body: ApprovalBody = { stepId, action, comment };
    const path: string = `/v0/${this._tenant}/${this._domain}/approvals`;

    return hmacCallApi(this._apiKey, this._apiSecret, {
      path: path,
      endpoint: this._endpoint,
      method: ACTION.POST,
      body,
    });
  };

  /**
   * Approve transaction
   * @async
   * @param {string} stepId approval step id
   * @param {string} [comment] comment on action (required by reject)
   * @returns {Promise<any>}
   */
  approveTransaction = async (stepId: string, comment?: string) => {
    return this.updateTransactionApproval(stepId, "approve", comment);
  };

  /**
   * Reject transaction
   * @async
   * @param {string} stepId approval step id
   * @param {string} comment comment on action
   * @returns {Promise<any>}
   */
  rejectTransaction = async (stepId: string, comment: string) => {
    return this.updateTransactionApproval(stepId, "reject", comment);
  };

  /**
   * Authorize transaction
   * @async
   * @param {string} transactionId transaction id
   * @param {Authorization} [body]
   * @param {string} [body.masterKey] authorizer's master key
   * @param {string} [body.challenge] challenge to be signed by authorizer
   * @param {string} [body.signature] signature of challenge
   * @returns
   */
  authorizeTransaction = async (transactionId: string, body: Authorization) => {
    return this.updateTransaction(transactionId, "authorize", body)
      .then((res) => {
        return res;
      })
      .catch((ex) => {
        throw ex;
      });
  };
}
